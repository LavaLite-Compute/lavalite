\documentclass[11pt,a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{titlesec}
\usepackage{enumitem}
\usepackage{lmodern}

\geometry{margin=2.5cm}
\setlist{nosep}
\titleformat{\section}{\bfseries\Large}{\thesection}{1em}{}
\titleformat{\subsection}{\bfseries\large}{\thesubsection}{1em}{}

\title{\textbf{LavaLite Modernization Manifest}}
\author{LavaLite Contributors}
\date{\today}

\begin{document}
\maketitle

\section{Vision}
LavaLite is a lightweight High Throughput Computing (HTC) scheduler designed
to continue the legacy of Platform Lava while evolving it into a modern,
data-driven, and extensible system.
The goal is not to reinvent job scheduling, but to make the proven LSF model
\textbf{2025-ready}: minimal, clean, and open.

\section{Rationale}
There is a need for simple batch execution and analytics workflows that do not
rely on container orchestration or heavyweight HPC schedulers.  Simple does not
mean unsophisticated—it means fast, intuitive, and maintainable. \textbf{LavaLite}
addresses this need with a lightweight scheduler rooted in the legacy of
Platform Lava 1.0 (2007).

\section{Core Principles}
\begin{enumerate}
  \item \textbf{KISS \& K\&R C} – Minimal, standard C. No decoration.
  \item \textbf{Functional Parity with LSF} – Preserve existing user workflows
        (\texttt{bsub}, \texttt{bjobs}, \texttt{bhosts}, etc.).
  \item \textbf{Modernization through Simplification} – Remove obsolete
        components (\texttt{res/nios}, i18n catalogs) and replace them with
        minimal equivalents.
  \item \textbf{Data-Driven Design} – Replace static analyzers with open
        data exports for Python, R, NumPy, and Grafana.
  \item \textbf{Streaming by Default} – Event-driven state reporting via
        Redis, ZeroMQ, or WebSockets.
  \item \textbf{Open Interfaces} – REST or gRPC endpoints for job
        submission and monitoring.
  \item \textbf{Scriptable Analytics} – Let users analyze data directly
        with R or Python instead of proprietary GUIs.
  \item \textbf{Compatibility Layer} – Transitional \texttt{\#define}s for
        CamelCase $\rightarrow$ snake\_case migration.
  \item \textbf{Transparent Scheduling Logic} – Algorithms remain explicit,
        inspectable, and modifiable.
  \item \textbf{No Decoration} – Every line of code has purpose.
\end{enumerate}

\section{Modernization Roadmap}
\subsection{Phase 1 – Core Cleanup}
Remove legacy i18n, RES/NIOS components, and fix unsafe \texttt{sprintf()} use.

\subsection{Phase 2 – Libraries and Daemons}
Rebuild batch library, \texttt{mbatchd}, \texttt{sbatchd};
replace inter-daemon channels with sockets.

\subsection{Phase 3 – Data Streaming Layer}
Publish metrics via Redis or REST; store in SQLite or NoSQL backend.

\subsection{Phase 4 – CLI \& API Modernization}
Maintain backward compatibility, add JSON/YAML output, REST endpoints.

\subsection{Phase 5 – Analytics and Prediction}
Expose data to Python/R notebooks, integrate predictive models.

\subsection{Phase 6 – Long-Term}
Add optional container/Kubernetes integration and plugin framework.

\section{Design Philosophy}
\begin{quote}
\textit{``Code is not decor, it's machinery.''}
\end{quote}

LavaLite must remain small enough for one engineer to audit in a week.
Reliability and clarity outweigh trendiness.

\section{Summary}
LavaLite brings the proven batch scheduling model into the data-centric era
by modernizing through subtraction, not addition.
It aims to be the \textbf{researcher's scheduler} —
small, understandable, streamable, and open.

\end{document}
